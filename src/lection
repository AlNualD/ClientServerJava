рефлексия ссылка на класс reflection
перегрузка методов  как в си

модификаторы
 static *к переменным
 она существует в единственном экз на все инстансы класса
 обращение класс.переменная
 существуют даже если нет объекта

        *к методам (кроме конструктора)
 допускает обращение класс.метод
 можно вызывать только статические методы, переменные  и нет this

        *к коду
        static {
        }
        будет выполнен один раз при начальной загрузке класса

  this
  исп чтобы обойти сокрытие переменных

  исп чтобы явно вызвать конструктор из другого конструктора explicit constructor invocation
  this (0,0,0,0); ссыль на другой конструктор

  Вложенные классы
  - статические (static nested classes) *статический член класса
  - нестатические (inner classes)
  {
  A a = new A();
  A.B b = a.new B();
  }

часто  исп для графических интерфейсов


наследование единичное. Один предок
class <subclass_name> extends <superclass_name>
по умолчанию вызывается контруктор без параметров
по правилам хорошего тона нужно явно задавать пустой конструктор
для того чтобы вызвать у супер класа не пустой конструктор должно быть
super (param) нужен только чтобы вызвать не пустой конструктор


ссылочная переменная суперкласса может хренить сылку на любой объект подкласса
но не использовать переменные определнные в подклассе

переопределение overriding в подклассе метод совпадающий по сигнатуре с методом суперкласса
динамическая диспетчеризация ^ как раз про ссылочные переменные
динамическая диспетчеризация методов
полиморфизм
одна ссылка может указыват на разные подклассы и соответственно использовать их методыю


абстрактные методы и классы
abstract позволяет не создавать тело метода но тогда и весь класс должен быть абстрактным
подкласс абстрактного класса обязан переопределить все его абстрактные методы иначе подкласс тоже должен быть абстрактным
объекты обстрактных классов не создатся, но конструктор может быть


интерфейсы
синтансическая конструкция содержит только абстрактные методы
и статические и дефолтные
имеется множественное наследование


чтобы использовать интерфейс нужно создать класс реализующий интерфейс
class name implements interf_name

ссылочные переменные интерфейсного типа могут вызывать

в интерфейсах могут быть константы


модификатор final
*неизменяемая локальная переменная аналог константы
*метод для которого запрещено переопределение
*класс для которого запрещено наследование

*экземплярную переменную можно определить только в конструкторе в момент созадния объекта внутри конструктора
преимущества final:
производительность и потокобезопасность
